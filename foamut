#!/usr/bin/env bash
# This script was generated by bashly 1.2.10 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script
# :command.root_command
root_command() {
  # src/root_command.sh
  # Main command logic for foamUT
  # Orchestrates the entire test execution pipeline

  # ShellChecked on every push - Always ShellCheck your scripts!

  # Validate custom test driver if provided
  if [ -n "${args[--test-driver]}" ]; then
      driver_path="${args[--test-driver]}"
      if [ ! -f "$driver_path" ]; then
          echo "Error: Test driver file not found: $driver_path" >&2
          exit 1
      fi
      if [[ ! "$driver_path" =~ \.(C|cpp)$ ]]; then
          echo "Error: Test driver must be a .C or .cpp source file" >&2
          exit 1
      fi
  fi

  # Validate --force-timeout is only used with --test-prefix
  if [ "${args[--force-timeout]}" = "1" ] && [ -z "${args[--test-prefix]}" ]; then
      echo "Warning: --force-timeout has no effect without --test-prefix" >&2
  fi

  # Validate --standalone is not used with --parallel
  if [ "${args[--standalone]}" = "1" ] && [ "${args[--parallel]}" = "1" ]; then
      echo "Error: --standalone is not compatible with --parallel" >&2
      echo "Standalone mode only runs serial tests" >&2
      exit 1
  fi

  # Validate --case is not used with --standalone
  if [ -n "${args[--case]}" ] && [ "${args[--standalone]}" = "1" ]; then
      echo "Error: --case is not compatible with --standalone" >&2
      exit 1
  fi

  # Load helper functions
  source "$root/src/lib/setup_test_symlinks.sh"
  source "$root/src/lib/create_dummy_libs.sh"
  source "$root/src/lib/compile_catch2.sh"
  source "$root/src/lib/compile_test_drivers.sh"
  source "$root/src/lib/run_serial_tests.sh"
  source "$root/src/lib/run_parallel_tests.sh"
  source "$root/src/lib/cleanup.sh"

  # Parse flags from bashly (bashly uses "1" for true flags)
  doSerial=true   # Default: serial only
  doParallel=false
  doReport=false
  standalone_mode=false

  # If --parallel flag is set, run parallel only (disable serial)
  if [ "${args[--parallel]}" = "1" ]; then
      doSerial=false
      doParallel=true
  fi

  if [ "${args[--report]}" = "1" ]; then
      doReport=true
  fi

  if [ "${args[--standalone]}" = "1" ]; then
      standalone_mode=true
  fi

  set -e

  # Get OpenFOAM version string
  foamV=$(echo "${WM_PROJECT}$(test ! -z "${WM_FORK}" && echo '-'"${WM_FORK}")-${WM_PROJECT_VERSION}")

  # Collect catch2 arguments from catch_all
  args_array=()
  if [ -n "${other_args[*]}" ]; then
      args_array=("${other_args[@]}")
  fi

  # Setup test symlinks if FOAM_FOAMUT_TESTS is set
  setup_test_symlinks

  # Create dummy libraries if needed
  create_dummy_libs

  # libraries to test
  libs=$(find -L tests/ -maxdepth 1 -mindepth 1 -type d)
  libs_array=($libs)

  # where to run OpenFOAM cases
  caseRun=/tmp/foamUtCases
  mkdir -p "$caseRun"

  # a timeout to prevent hanging processes (be CI friendly)
  timeOut="${CATCH_TIMEOUT:-60}"

  # Compile Catch2
  compile_catch2

  # Compile test drivers
  compile_test_drivers

  # Go back to the root of the repository
  cd "$root"

  # Get setup to run tests
  mapfile -t cases_array < <(find -L cases/ -maxdepth 1 -mindepth 1 -type d)

  # Build list of case names for tag filtering
  case_names=()
  for case_dir in "${cases_array[@]}"; do
      case_names+=("$(basename "$case_dir")")
  done

  if [ "$standalone_mode" = "true" ]; then
      echo "Running in standalone mode (no OpenFOAM cases)..." >&2
      echo "Will exclude tests tagged with: ${case_names[*]}" >&2
      # Create a dummy case array with one entry for the loop structure
      cases_array=("standalone")
  else
      if [ ${#cases_array[@]} -eq 0 ]; then
          echo "No cases found to run tests"
          exit 1
      fi

      # Filter to specific case if --case is provided
      if [ -n "${args[--case]}" ]; then
          selected_case="${args[--case]}"
          found_case=""
          for case_dir in "${cases_array[@]}"; do
              if [ "$(basename "$case_dir")" = "$selected_case" ]; then
                  found_case="$case_dir"
                  break
              fi
          done
          if [ -z "$found_case" ]; then
              echo "Error: Case '$selected_case' not found in cases/" >&2
              echo "Available cases: ${case_names[*]}" >&2
              exit 1
          fi
          cases_array=("$found_case")
          echo "Running tests on case: $selected_case" >&2
      fi
  fi

  mkdir -p "$root"/reports

  # Run the tests, but do not exit until attempting everything
  set +e
  err=0

  for ((k = 0; k < ${#cases_array[@]}; k++)); do
      if [ "$standalone_mode" = "true" ]; then
          caseName="standalone"
          casePath=""
          echo "Running standalone tests (no case)..." >&2
      else
          ofCase="${cases_array[k]}"
          caseName=$(basename "$ofCase")
          casePath=$caseRun/$caseName
          cp -rL "$ofCase" "$casePath"
      fi

      case $doSerial in
          (true) run_serial_tests "$err" "$caseName" "$casePath" "$libs" "${args_array[@]}";;
      esac

      case $doParallel in
          (true) run_parallel_tests "$err" "$caseName" "$casePath" "$libs" "${args_array[@]}";;
      esac

      # separator in case json reporter is used
      for element in "${args_array[@]}"; do
          if [ "$element" == "json" ]; then
              if ((k != ${#cases_array[@]} - 1)); then
                  printf ","
              fi
          fi
      done

      # Cleanup case directory if not in standalone mode
      if [ "$standalone_mode" != "true" ]; then
          rm -rf "$casePath"
      fi
  done

  # Cleanup
  cleanup

  exit $err

}

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
foamut_usage() {
  printf "foamut - Unit/integration testing framework for OpenFOAM\n\n"

  printf "%s\n" "Usage:"
  printf "  foamut [OPTIONS] [--] [CATCH2_ARGS...]\n"
  printf "  foamut --help | -h\n"
  printf "  foamut --version | -v\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--parallel"
    printf "    Run parallel tests only (default is serial only, incompatible with\n    --standalone)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--mpirun-options OPTIONS"
    printf "    Comma-separated mpirun options (requires --parallel)\n    Each option will be prefixed with -- when passed to mpirun\n    Example: --mpirun-options oversubscribe,use-hwthread-cpus\n    Results in: mpirun --oversubscribe --use-hwthread-cpus ...\n"
    echo

    # :flag.usage
    printf "  %s\n" "--report"
    printf "    Generate JSON test reports in reports/ directory\n"
    echo

    # :flag.usage
    printf "  %s\n" "--test-driver SOURCE_PATH"
    printf "    Path to custom testDriver.C source file (overrides default)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--standalone"
    printf "    Run tests without OpenFOAM cases (tests not tagged by case names, serial or\n    mode-agnostic)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--test-prefix COMMAND"
    printf "    Prefix command for test execution (automatically disables timeout)\n    Serial: <prefix> testDriver ...\n    Parallel: mpirun -np N <prefix> testDriver ...\n    Examples: \"gdb --args\", \"valgrind\", \"hpctoolkit\"\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force-timeout"
    printf "    Keep timeout wrapper even when using --test-prefix\n"
    echo

    # :flag.usage
    printf "  %s\n" "--case CASE_NAME"
    printf "    Run tests on a specific case only (by name, not path)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    echo "  CATCH2_ARGS..."
    printf "    Arguments passed to Catch2 test framework.\n    \n    Common Catch2 Options:\n      --list-tests                    List all tests\n      --list-tags                     List all tags\n      -h, --help                      Show Catch2 help\n      -s, --success                   Show successful tests\n      -b, --break                     Break into debugger on failure\n      -d, --durations <yes|no>        Show test durations\n      -#, --filenames-as-tags         Add filename as tag\n      -r, --reporter <name>           Use specific reporter (console, xml,\n    junit, etc.)\n      --order <decl|lex|rand>         Test execution order\n    \n    Tag Filters:\n      \"[tag1]\"                        Run tests with tag1\n      \"[tag1][tag2]\"                  Run tests with both tags\n      \"[tag1],[tag2]\"                 Run tests with either tag\n      \"~[tag1]\"                       Exclude tests with tag1\n    \n    Note: testDriver uses --- to separate Catch2 from OpenFOAM args internally\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "FOAM_LIBBIN"
    printf "    OpenFOAM library directory (required, set by sourcing OpenFOAM)\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "FOAM_FOAMUT_TESTS"
    printf "    Path to external tests directory (will be symlinked under tests/)\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "CATCH_TIMEOUT"
    printf "    Test timeout in seconds (default 60)\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "FOAM_FOAMUT"
    printf "    Path to foamUT repository root (set automatically)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  foamut --help\n"
    printf "  foamut\n"
    printf "  foamut --parallel\n"
    printf "  foamut --parallel --mpirun-options oversubscribe\n"
    printf "  foamut --parallel --report\n"
    printf "  foamut --standalone\n"
    printf "  foamut --case cavity\n"
    printf "  foamut --list-tests\n"
    printf "  foamut \"[serial]\"\n"
    printf "  foamut -s\n"
    printf "  foamut --test-prefix \"gdb --args\"\n"
    printf "  foamut --test-driver /path/to/custom/testDriver.C\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/cleanup.sh
#!/usr/bin/bash

# Cleanup dummy libraries and temporary directories

cleanup() {
    local dummyLibChecks="Pstream dynamicFvMesh"

    # Cleanup dummy libraries
    for dummy in $dummyLibChecks; do
        if [ -f "${FOAM_USER_LIBBIN}/lib${dummy}.so" ] &&
            tr '\n' ' ' < "${FOAM_USER_LIBBIN}/lib${dummy}.so" | grep -q '^!<arch> $'; then
            rm -rf "${FOAM_USER_LIBBIN}/lib${dummy}.so"
        fi
    done

    # Cleanup temporary case directory
    rm -rf "$caseRun"
}

# src/lib/compile_catch2.sh
#!/usr/bin/bash

# Compile Catch2 v3 if not already compiled
# Installs to FOAM_USER_LIBBIN/catch2

compile_catch2() {
    echo "Compiling Catch2 v3..." >&2
    if [ ! -f "$FOAM_USER_LIBBIN/catch2/lib/libCatch2.a" ]; then
        cd catch2 || exit 1
        mkdir -p build
        cd build || exit 1

        # Use pipefail to catch failures in piped commands
        set -o pipefail

        if ! cmake -DCMAKE_INSTALL_PREFIX="$FOAM_USER_LIBBIN"/catch2 .. 2>&1 | tee log.cmake; then
            set +o pipefail
            echo "" >&2
            echo "Error: CMake configuration failed for Catch2" >&2
            echo "Full log saved to: $PWD/log.cmake" >&2
            exit 1
        fi

        if ! make -j"$(nproc)" 2>&1 | tee log.makeBuild; then
            set +o pipefail
            echo "" >&2
            echo "Error: Failed to build Catch2" >&2
            echo "Full log saved to: $PWD/log.makeBuild" >&2
            exit 1
        fi

        if ! make install 2>&1 | tee log.makeInstall; then
            set +o pipefail
            echo "" >&2
            echo "Error: Failed to install Catch2" >&2
            echo "Full log saved to: $PWD/log.makeInstall" >&2
            exit 1
        fi

        set +o pipefail
        cd - > /dev/null || exit 1
        rm -rf build
        cd .. || exit 1
    fi
}

# src/lib/compile_test_drivers.sh
#!/usr/bin/bash

# Compile test drivers for all test libraries
# Supports custom test driver via --test-driver flag

compile_test_drivers() {
    local custom_driver="${args[--test-driver]}"

    # Compile tests
    for lib in $libs; do
        cd "$lib" || exit 1

        # If custom driver is specified, copy it to this test directory
        if [ -n "$custom_driver" ]; then
            cp "$custom_driver" "$root/tests/testDriver.C"
            echo "Using custom test driver: $custom_driver" >&2
        fi

        echo "Compiling $lib test driver..." >&2
        wmakeLnInclude . # Just in case the tested libs are header only

        # Use set -o pipefail to catch wmake failures even when piped to tee
        set -o pipefail
        if ! wmake 2>&1 | tee log.wmake; then
            set +o pipefail
            echo "" >&2
            echo "Error: Failed to compile $lib test driver" >&2
            echo "Full log saved to: $PWD/log.wmake" >&2
            exit 1
        fi
        set +o pipefail
        echo "Test driver for $lib has been compiled." >&2
        cd - > /dev/null || exit 1
    done
}

# src/lib/create_dummy_libs.sh
#!/usr/bin/bash

# Create dummy libraries if they don't exist
# Some OpenFOAM forks/configurations may not have certain libraries

create_dummy_libs() {
    # If there is no lib${libName}.so, create a dummy one
    local dummyLibChecks="Pstream dynamicFvMesh"
    for dummy in $dummyLibChecks; do
        if [ ! -f "${FOAM_LIBBIN}/lib${dummy}.so" ] &&
            [ ! -f "${FOAM_USER_LIBBIN}/lib${dummy}.so" ] &&
            [ ! -f "${FOAM_LIBBIN}/${FOAM_MPI}/lib${dummy}.so" ]; then
            echo '!<arch>' > "${FOAM_USER_LIBBIN}/lib${dummy}.so"
        fi
    done
}

# src/lib/run_parallel_tests.sh
#!/usr/bin/bash

# Run parallel tests for all libraries on a specific case
# Arguments: $1=error_count, $2=case_name, $3=case_path, $4=libs, $@=additional args

run_parallel_tests() {
    if [ "$standalone_mode" = "true" ]; then
        echo "Skipping decomposePar for standalone mode..." >&2
    else
        if ! test -f "${3}/system/decomposeParDict" ; then
            rm -rf "${3}/processor*"
            echo "decomposeParDict not found, not running parallel tests on this case..." >&2
            return 0
        fi
    fi

    local fargs=("$@")
    local params=()
    local skip_next=false

    # Filter out foamUT-specific flags from params
    for ((i = 4; i <= $#; i++)); do
        arg="${fargs[i]}"

        if [ "$skip_next" = true ]; then
            skip_next=false
            continue
        fi

        case "$arg" in
            --parallel|--report|--standalone|--force-timeout)
                # These flags don't take arguments
                ;;
            --test-driver|--test-prefix|--case|--mpirun-options)
                # These flags take an argument, skip the next one too
                skip_next=true
                ;;
            *)
                params+=("$arg")
                ;;
        esac
    done

    local test_prefix="${args[--test-prefix]}"
    local force_timeout="${args[--force-timeout]}"

    # Parse mpirun options: convert comma-separated list to --prefixed options
    local mpirun_opts=""
    if [ -n "${args[--mpirun-options]}" ]; then
        IFS=',' read -ra mpi_opt_array <<< "${args[--mpirun-options]}"
        for opt in "${mpi_opt_array[@]}"; do
            mpirun_opts="$mpirun_opts --$opt"
        done
    fi

    # Decompose case if not in standalone mode
    if [ "$standalone_mode" != "true" ]; then
        local nProcs=$(grep -oP "numberOfSubdomains\s+\K\d+" "${3}"/system/decomposeParDict)
        decomposePar -force -case "${3}" > "${3}/log.decomposePar"
        err=$((err + $?))
    else
        # In standalone mode, default to 2 processors or read from FOAM_FOAMUT_NPROCS
        local nProcs="${FOAM_FOAMUT_NPROCS:-2}"
    fi

    # run the case in parallel mode
    report=""
    case $doReport in
        (true) report="-s -r json -d yes";;
    esac

    for ((i = 0; i < ${#libs_array[@]}; i++)); do
        lib="${libs_array[i]}"
        printf "\n\nRunning tests for lib %s, on %s case in parallel...\n" "$lib" "${2}" >&2
        libName=$(basename "$lib")
        logdir="reports/${libName}_${2}_parallel"
        logparams=""
        direct=""
        case $doReport in
            (true) logparams="-output-filename $logdir"
                direct="> /dev/null"
                echo "Parallel Reports (${nProcs}): ${logdir}" >&2
        esac

        # Execute the test
        if [ "$standalone_mode" = "true" ]; then
            # Standalone mode: no case argument, exclude all case-tagged tests
            # Build exclusion filter: [parallel]~[case1]~[case2]...
            local tag_filter="[parallel]"
            for case_name in "${case_names[@]}"; do
                tag_filter="${tag_filter}~[${case_name}]"
            done

            # Build and execute command with or without timeout and prefix
            # Prefix comes AFTER mpirun in parallel mode
            if [ -z "$test_prefix" ]; then
                timeout "$timeOut" mpirun$mpirun_opts $logparams -np "$nProcs" "$root"/"$lib"/testDriver \
                    --allow-running-no-tests \
                    -n "$(basename "$lib")" $report \
                    --rng-seed time "$tag_filter" "${params[@]}" --- -parallel $direct
            else
                if [ "$force_timeout" = "1" ]; then
                    timeout "$timeOut" mpirun$mpirun_opts $logparams -np "$nProcs" $test_prefix "$root"/"$lib"/testDriver \
                        --allow-running-no-tests \
                        -n "$(basename "$lib")" $report \
                        --rng-seed time "$tag_filter" "${params[@]}" --- -parallel $direct
                else
                    mpirun$mpirun_opts $logparams -np "$nProcs" $test_prefix "$root"/"$lib"/testDriver \
                        --allow-running-no-tests \
                        -n "$(basename "$lib")" $report \
                        --rng-seed time "$tag_filter" "${params[@]}" --- -parallel $direct
                fi
            fi
        else
            # Normal mode: with case argument and -parallel flag
            if [ -z "$test_prefix" ]; then
                timeout "$timeOut" mpirun$mpirun_opts $logparams -np "$nProcs" "$root"/"$lib"/testDriver \
                    --allow-running-no-tests \
                    -n "$(basename "$lib")" $report \
                    --rng-seed time "[parallel][${2}]" "${params[@]}" --- -parallel -case "${3}" $direct
            else
                if [ "$force_timeout" = "1" ]; then
                    timeout "$timeOut" mpirun$mpirun_opts $logparams -np "$nProcs" $test_prefix "$root"/"$lib"/testDriver \
                        --allow-running-no-tests \
                        -n "$(basename "$lib")" $report \
                        --rng-seed time "[parallel][${2}]" "${params[@]}" --- -parallel -case "${3}" $direct
                else
                    mpirun$mpirun_opts $logparams -np "$nProcs" $test_prefix "$root"/"$lib"/testDriver \
                        --allow-running-no-tests \
                        -n "$(basename "$lib")" $report \
                        --rng-seed time "[parallel][${2}]" "${params[@]}" --- -parallel -case "${3}" $direct
                fi
            fi
        fi

        locErr=$?
        err=$((err + locErr))

        # separator in case json reporter is used
        for element in "${params[@]}"; do
            if [ "$element" == "json" ]; then
                if ((i != ${#libs_array[@]} - 1)); then
                    printf ","
                fi
            fi
        done
    done
}

# src/lib/run_serial_tests.sh
#!/usr/bin/bash

# Run serial tests for all libraries on a specific case
# Arguments: $1=error_count, $2=case_name, $3=case_path, $4=libs, $@=additional args

run_serial_tests() {
    local fargs=("$@")
    local params=()
    local skip_next=false

    # Filter out foamUT-specific flags from params
    for ((i = 4; i <= $#; i++)); do
        arg="${fargs[i]}"

        if [ "$skip_next" = true ]; then
            skip_next=false
            continue
        fi

        case "$arg" in
            --parallel|--report|--standalone|--force-timeout)
                # These flags don't take arguments
                ;;
            --test-driver|--test-prefix|--case)
                # These flags take an argument, skip the next one too
                skip_next=true
                ;;
            *)
                params+=("$arg")
                ;;
        esac
    done

    local test_prefix="${args[--test-prefix]}"
    local force_timeout="${args[--force-timeout]}"

    for ((i = 0; i < ${#libs_array[@]}; i++)); do
        lib="${libs_array[i]}"
        printf "\n\nRunning tests for lib %s, on %s case in serial...\n" "$lib" "${2}" >&2
        libName=$(basename "$lib")
        report=""
        case $doReport in
            (true) report="-s -r json::out=${root}/reports/${libName}_${2}_serial.json -d yes"
            echo "Report: ${root}/reports/${libName}_${2}_serial.json" >&2
            ;;
        esac

        # Execute the test
        if [ "$standalone_mode" = "true" ]; then
            # Standalone mode: no case argument, exclude all case-tagged tests
            # Run tests that are:
            #   - ([serial] AND not-case-tagged) OR (not-[parallel] AND not-case-tagged)
            # This includes: [serial] tests, and tests with neither [serial] nor [parallel]
            local tag_filter="[serial]"
            for case_name in "${case_names[@]}"; do
                tag_filter="${tag_filter}~[${case_name}]"
            done
            tag_filter="${tag_filter},~[parallel]"
            for case_name in "${case_names[@]}"; do
                tag_filter="${tag_filter}~[${case_name}]"
            done

            # Build and execute command with or without timeout and prefix
            if [ -z "$test_prefix" ]; then
                timeout "$timeOut" "$root"/"$lib"/testDriver --allow-running-no-tests \
                    -n "$(basename "$lib")" $report "$tag_filter" "${params[@]}"
            else
                if [ "$force_timeout" = "1" ]; then
                    timeout "$timeOut" $test_prefix "$root"/"$lib"/testDriver --allow-running-no-tests \
                        -n "$(basename "$lib")" $report "$tag_filter" "${params[@]}"
                else
                    $test_prefix "$root"/"$lib"/testDriver --allow-running-no-tests \
                        -n "$(basename "$lib")" $report "$tag_filter" "${params[@]}"
                fi
            fi
        else
            # Normal mode: with case argument
            if [ -z "$test_prefix" ]; then
                timeout "$timeOut" "$root"/"$lib"/testDriver --allow-running-no-tests \
                    -n "$(basename "$lib")" $report "[serial][${2}]" "${params[@]}" \
                    --- -case "${3}"
            else
                if [ "$force_timeout" = "1" ]; then
                    timeout "$timeOut" $test_prefix "$root"/"$lib"/testDriver --allow-running-no-tests \
                        -n "$(basename "$lib")" $report "[serial][${2}]" "${params[@]}" \
                        --- -case "${3}"
                else
                    $test_prefix "$root"/"$lib"/testDriver --allow-running-no-tests \
                        -n "$(basename "$lib")" $report "[serial][${2}]" "${params[@]}" \
                        --- -case "${3}"
                fi
            fi
        fi

        locErr=$?
        err=$((err+locErr))

        # separator in case json reporter is used
        for element in "${params[@]}"; do
            if [ "$element" == "json" ]; then
                if ((i != ${#libs_array[@]})); then
                    printf ","
                fi
            fi
        done
    done
}

# src/lib/setup_test_symlinks.sh
#!/usr/bin/bash

# Setup test symlinks if FOAM_FOAMUT_TESTS environment variable is set
# Discovers Make directories and symlinks parent directories under tests/

setup_test_symlinks() {
    # If tests folder is supplied through an env. var. do the symlinking
    if [ -n "${FOAM_FOAMUT_TESTS}" ]; then
        find "${FOAM_FOAMUT_TESTS}" -type d -name "Make" | while read -r make_dir; do
            parent_dir=$(basename "$(dirname "$make_dir")")
            target_dir="$root/tests/$parent_dir"
            ln -f -s "$(dirname "$make_dir")" "$target_dir"
            echo "picked up $parent_dir tests"
        done
    fi
}

# :command.command_functions

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        foamut_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter

  env_var_names+=("FOAM_LIBBIN")
  env_var_names+=("FOAM_FOAMUT_TESTS")
  env_var_names+=("CATCH_TIMEOUT")
  env_var_names+=("FOAM_FOAMUT")

  # :command.command_filter
  action="root"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --parallel)

        # :flag.case_no_arg
        args['--parallel']=1
        shift
        ;;

      # :flag.case
      --mpirun-options)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--mpirun-options']="$2"
          shift
          shift
        else
          printf "%s\n" "--mpirun-options requires an argument: --mpirun-options OPTIONS" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --report)

        # :flag.case_no_arg
        args['--report']=1
        shift
        ;;

      # :flag.case
      --test-driver)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--test-driver']="$2"
          shift
          shift
        else
          printf "%s\n" "--test-driver requires an argument: --test-driver SOURCE_PATH" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --standalone)

        # :flag.case_no_arg
        args['--standalone']=1
        shift
        ;;

      # :flag.case
      --test-prefix)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--test-prefix']="$2"
          shift
          shift
        else
          printf "%s\n" "--test-prefix requires an argument: --test-prefix COMMAND" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --force-timeout)

        # :flag.case_no_arg
        args['--force-timeout']=1
        shift
        ;;

      # :flag.case
      --case)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--case']="$2"
          shift
          shift
        else
          printf "%s\n" "--case requires an argument: --case CASE_NAME" >&2
          exit 1
        fi
        ;;

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="2.0.0"
  set -e

  # src/initialize.sh
  #!/usr/bin/bash

  # Bashly initialization hook - runs before command execution
  # Validates environment and performs sanity checks

  # Check if OpenFOAM is sourced
  if [ -z "${FOAM_LIBBIN}" ]; then
      echo "Error: Please source an OpenFOAM version. Aborting..." >&2
      echo "USAGE: ./foamut [OPTIONS] [CATCH2_ARGS...]" >&2
      exit 1
  fi

  # Set root directory as the repository root
  root="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  export FOAM_FOAMUT="$root"

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -a other_args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "root") root_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  initialize
  run "$@"
fi
